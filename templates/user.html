<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice-Enabled Bus Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script src="https://api.backendless.com/sdk/js/latest/backendless.min.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        html, body { overflow: hidden; height: 100%; width: 100%; }
        .chat-container { display: flex; flex-direction: column; height: 100%; }
        .chat-messages { flex-grow: 1; overflow-y: auto; padding: 1rem; }
        .message { margin-bottom: 1rem; display: flex; flex-direction: column; }
        .bot-message .message-content { background-color: #e5e7eb; align-self: flex-start; }
        .user-message .message-content { background-color: #3b82f6; color: white; align-self: flex-end; }
        .message-content { padding: 0.75rem 1rem; border-radius: 0.75rem; max-width: 95%; line-height: 1.5; }
        #map { height: 100%; width: 100%; border-radius: 0.5rem; z-index: 0; }
        .search-again-btn { background-color: #10b981; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.5rem; margin-top: 0.75rem; cursor: pointer; font-weight: 500; }
        .search-again-btn:hover { background-color: #059669; }
        .details-list { list-style: none; padding: 0; margin: 0; }
        .details-list li { padding: 0.3rem 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #e5e7eb; }
        .details-list li:last-child { border-bottom: none; }
        .details-list li strong { margin-right: 1rem; color: #4b5563; font-size: 0.9rem; }
        .details-list-value { text-align: right; font-weight: 500; }
        .section-title { font-weight: 700; font-size: 1.1rem; color: #1f2937; padding-bottom: 0.5rem; margin-top: 0.75rem; margin-bottom: 0.5rem; border-bottom: 2px solid #d1d5db; }
        .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }
        .info-card { background-color: #f3f4f6; padding: 0.75rem; border-radius: 0.5rem; text-align: center;}
        .info-card h3 { font-weight: 600; margin-bottom: 0.25rem; font-size: 0.85rem; }
        .info-card p { font-size: 1rem; font-weight: 700; }
        #mic-btn {
            background-color: #6b7280; color: white; border: none; border-radius: 0.5rem; width: 52px;
            display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s;
        }
        #mic-btn:hover { background-color: #4b5563; }
        #mic-btn.is-listening { background-color: #ef4444; }
    </style>
</head>
<body class="bg-gray-100">

    <div class="w-full h-screen max-w-screen-2xl mx-auto flex p-4 gap-4">
        <div class="w-full md:w-1/3 lg:w-1/3 flex flex-col bg-white rounded-lg shadow-2xl chat-container">
            <header class="bg-gray-800 text-white p-4 rounded-t-lg flex justify-between items-center flex-shrink-0">
                <h1 class="text-xl font-bold">Bus Assistant</h1>
                <div>
                    <select id="language-select" class="bg-gray-700 text-white rounded-md p-1 text-sm">
                        <option value="en-IN">English</option>
                        <option value="hi-IN">Hindi</option>
                        <option value="te-IN">Telugu</option>
                        <option value="ta-IN">Tamil</option>
                    </select>
                </div>
            </header>
            <div id="chat-messages" class="chat-messages"></div>
            <footer class="p-4 border-t flex-shrink-0">
                <div class="flex space-x-2">
                    <input type="text" id="user-input" placeholder="Ask or tap the mic..." class="flex-grow border rounded-lg p-3 focus:ring-2 focus:ring-blue-500 focus:outline-none disabled:bg-gray-200">
                    <button id="mic-btn" title="Ask with voice">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" /></svg>
                    </button>
                    <button id="send-btn" class="bg-blue-600 text-white font-semibold px-4 py-3 rounded-lg hover:bg-blue-700 disabled:bg-blue-400">Send</button>
                </div>
            </footer>
        </div>
        <div id="map" class="w-full md:w-2/3 lg:w-2/3 h-[calc(100vh-2rem)] rounded-lg shadow-2xl"></div>
    </div>


    <script>
        // --- CONFIGURATION ---
        const BACKENDLESS_APP_ID = '7A748A24-7BDE-48E4-B794-E1F6CF1E9CF2';
        const BACKENDLESS_API_KEY = '4F8AE28B-AB86-40D7-94FB-6F1BF8C639E6';
        const ORS_API_KEY = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjFhYTUzNzY1MTE2ODFiZDRmNmJmMTMyMmM4N2FjYTJiZmRjNDQ1YTRlYjAyNTg2MzJkZjdlMjkzIiwiaCI6Im11cm11cjY0In0=';

        // --- DOM ELEMENTS & SPEECH API SETUP ---
        const chatMessages = document.getElementById('chat-messages');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const langSelect = document.getElementById('language-select');
        const micBtn = document.getElementById('mic-btn');

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
        } else {
            micBtn.style.display = 'none';
        }
        
        // --- GLOBAL STATE ---
        let userLocation = null;
        let currentBusData = null;
        let trackingInterval = null;
        let mapInstance = null;
        let userMarker = null;
        let busMarker = null;
        let stopMarker = null;
        let routeLayers = L.layerGroup();
        
        // --- TRANSLATIONS ---
        const placeNameTranslations = {
            'Madurai': { 'hi-IN': 'рдорджреБрд░реИ', 'te-IN': 'р░ор░зр▒Бр░░р▒И', 'ta-IN': 'роородрпБро░рпИ' },
            'Rajapalayam': { 'hi-IN': 'рд░рд╛рдЬрд╛рдкрд▓рд╛рдпрдо', 'te-IN': 'р░░р░╛р░Ьр░кр░╛р░▓р░пр░В', 'ta-IN': 'ро░ро╛роЬрокро╛ро│рпИропроорпН' },
            'Srivilliputhur': { 'hi-IN': 'рд╢реНрд░реАро╡ро┐ро▓рпНрд▓рд┐рдкреБрдереБрд░', 'te-IN': 'р░╢р▒Нр░░р▒Ар░╡р░┐р░▓р▒Нр░▓р░┐р░кр▒Бр░др▒Нр░др▒Вр░░р▒Б', 'ta-IN': 'ро╕рпНро░рпАро╡ро┐ро▓рпНро▓ро┐рокрпБродрпНродрпВро░рпН' }
        };

        const numberWords = {
            // English
            'one': '1', 'two': '2', 'three': '3', 'four': '4', 'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9', 'ten': '10',
            // Hindi
            'рдПрдХ': '1', 'рджреЛ': '2', 'рддреАрди': '3', 'рдЪрд╛рд░': '4', 'рдкрд╛рдВрдЪ': '5', 'рдЫрд╣': '6', 'рд╕рд╛рдд': '7', 'рдЖрда': '8', 'рдиреМ': '9', 'рджрд╕': '10',
            // Telugu
            'р░Тр░Хр░Яр░┐': '1', 'р░░р▒Жр░Вр░бр▒Б': '2', 'р░ор▒Вр░бр▒Б': '3', 'р░ир░╛р░▓р▒Бр░Чр▒Б': '4', 'р░Рр░жр▒Б': '5', 'р░Жр░░р▒Б': '6', 'р░Пр░бр▒Б': '7', 'р░Ор░ир░┐р░ор░┐р░жр░┐': '8', 'р░др▒Кр░ор▒Нр░ор░┐р░жр░┐': '9', 'р░кр░жр░┐': '10', 'р░╡р░ир▒Н': '1',
            // Tamil
            'роТройрпНро▒рпБ': '1', 'роЗро░рогрпНроЯрпБ': '2', 'роорпВройрпНро▒рпБ': '3', 'роиро╛ройрпНроХрпБ': '4', 'роРроирпНродрпБ': '5', 'роЖро▒рпБ': '6', 'роПро┤рпБ': '7', 'роОроЯрпНроЯрпБ': '8', 'роТройрпНрокродрпБ': '9', 'рокродрпНродрпБ': '10'
        };

        const translations = {
            'en-IN': {
                welcome: "Welcome! Tap the mic or enter a bus number.", searching: "Hold on, I'm checking for that bus number...", no_bus: "Sorry, no bus was found with that number.", bus_found: "Great! I found the bus. Here is its live status:", direct_dist_message: "ЁЯЪН...ЁЯзНThe bus is approx. <strong>{distance} km</strong> away. Estimated driving time to it is <strong>{time} minutes</strong>.", bus_arriving_message: "The bus is arriving at your location now!", bus_details_title: "Bus #{busNumber} Details", intercept_plan_title: "Intercept Plan ЁЯЧ║я╕П", intercept_stop_message: "The best upcoming stop for you to catch the bus is: <strong>{stopName}</strong>", eta_user: "You to Stop", eta_bus: "Bus to Stop", search_again: "Search Again", getting_location: "Getting your location...", location_confirmed: "I've detected your location near <strong>{city}</strong>. You can now search for a bus.", location_error: "Could not get your location. Please grant permission and refresh.", no_live_location: "This bus was found, but it's not broadcasting its live location right now.", bus_not_active: "Bus {busNumber} was found, but it is currently not in service. Its status is: {status}.", last_updated: "Last Updated", driver_name: "Driver", driver_mobile: "Driver Mobile", available_seats: "Available Seats", total_seats: "Total Seats", route: "Route", number_plate: "Vehicle No.", weather: "Weather", need_bus_context: "Please find a bus first before asking about its details.", not_provided: "Not provided", sms_title: "Get SMS Updates ЁЯУ▒", phone_placeholder: "Enter your phone number...", sms_btn_text: "Send SMS", sending_sms: "Sending...", sms_sent: "тЬЕ SMS sent successfully!", sms_error: "тЭМ Could not send SMS. Please try again.", unrecognized_bus_number: "I didn't recognize a bus number. Please try again."
            },
            'hi-IN': {
                welcome: "рдЖрдкрдХрд╛ рд╕реНрд╡рд╛рдЧрдд рд╣реИ! рдмрд╕ рдЦреЛрдЬрдиреЗ рдХреЗ рд▓рд┐рдП рдкреВрдЫреЗрдВ, рдпрд╛ рдмреЛрд▓рдиреЗ рдХреЗ рд▓рд┐рдП рдорд╛рдЗрдХ рдкрд░ рдЯреИрдк рдХрд░реЗрдВред", searching: "рд░реБрдХрд┐рдП, рдореИрдВ рдЙрд╕ рдмрд╕ рдирдВрдмрд░ рдХреА рдЬрд╛рдВрдЪ рдХрд░ рд░рд╣рд╛ рд╣реВрдВ...", no_bus: "рдорд╛рдлрд╝ рдХреАрдЬрд┐рдП, рдореБрдЭреЗ рдЙрд╕ рдирдВрдмрд░ рд╡рд╛рд▓реА рдХреЛрдИ рдмрд╕ рдирд╣реАрдВ рдорд┐рд▓реАред", bus_found: "рдмрд╣реБрдд рдмрдврд╝рд┐рдпрд╛! рдореБрдЭреЗ рдмрд╕ рдорд┐рд▓ рдЧрдИред рдпрд╣рд╛рдБ рдЗрд╕рдХреА рд▓рд╛рдЗрд╡ рд╕реНрдерд┐рддрд┐ рд╣реИ:", direct_dist_message: "ЁЯЪН...ЁЯзНрдмрд╕ рдЖрдкрд╕реЗ рд▓рдЧрднрдЧ <strong>{distance} рдХрд┐рдореА</strong> рджреВрд░ рд╣реИред рд╡рд╣рд╛рдВ рддрдХ тАЛтАЛрдкрд╣реБрдВрдЪрдиреЗ рдХрд╛ рдЕрдиреБрдорд╛рдирд┐рдд рд╕рдордп <strong>{time} рдорд┐рдирдЯ</strong> рд╣реИред", bus_arriving_message: "рдмрд╕ рдЕрдм рдЖрдкрдХреЗ рд╕реНрдерд╛рди рдкрд░ рдкрд╣реБрдВрдЪ рд░рд╣реА рд╣реИ!", bus_details_title: "рдмрд╕ #{busNumber} рд╡рд┐рд╡рд░рдг", intercept_plan_title: "рдЗрдВрдЯрд░рд╕реЗрдкреНрдЯ рдкреНрд▓рд╛рди ЁЯЧ║я╕П", intercept_stop_message: "рдмрд╕ рдкрдХрдбрд╝рдиреЗ рдХреЗ рд▓рд┐рдП рд╕рдмрд╕реЗ рдЕрдЪреНрдЫрд╛ рд╕реНрдЯреЙрдк рд╣реИ: <strong>{stopName}</strong>", eta_user: "рдЖрдкрдХреА рд╕реНрдЯреЙрдк рддрдХ", eta_bus: "рдмрд╕ рдХреА рд╕реНрдЯреЙрдк рддрдХ", search_again: "рдлрд┐рд░ рд╕реЗ рдЦреЛрдЬреЗрдВ", getting_location: "рдЖрдкрдХрд╛ рд▓реЛрдХреЗрд╢рди рд▓рд┐рдпрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИ...", location_confirmed: "рдореИрдВрдиреЗ рдЖрдкрдХрд╛ рд▓реЛрдХреЗрд╢рди <strong>{city}</strong> рдХреЗ рдкрд╛рд╕ рдкрд╛рдпрд╛ рд╣реИред рдЕрдм рдЖрдк рдмрд╕ рдЦреЛрдЬ рд╕рдХрддреЗ рд╣реИрдВред", location_error: "рдЖрдкрдХрд╛ рд▓реЛрдХреЗрд╢рди рдирд╣реАрдВ рдорд┐рд▓ рд╕рдХрд╛ред рдХреГрдкрдпрд╛ рдЕрдиреБрдорддрд┐ рджреЗрдВ рдФрд░ рдкреЗрдЬ рдХреЛ рд░рд┐рдлреНрд░реЗрд╢ рдХрд░реЗрдВред", no_live_location: "рдпрд╣ рдмрд╕ рдорд┐рд▓ рдЧрдИ рд╣реИ, рд▓реЗрдХрд┐рди рдЕрднреА рдЗрд╕рдХрд╛ рд▓рд╛рдЗрд╡ рд▓реЛрдХреЗрд╢рди рдкреНрд░рд╕рд╛рд░рд┐рдд рдирд╣реАрдВ рд╣реЛ рд░рд╣рд╛ рд╣реИред", bus_not_active: "рдмрд╕ {busNumber} рдорд┐рд▓ рдЧрдИ, рд▓реЗрдХрд┐рди рдпрд╣ рдЕрднреА рд╕реЗрд╡рд╛ рдореЗрдВ рдирд╣реАрдВ рд╣реИред рдЗрд╕рдХреА рд╕реНрдерд┐рддрд┐ рд╣реИ: {status}ред", last_updated: "рдЕрдВрддрд┐рдо рдЕрдкрдбреЗрдЯ", driver_name: "рдбреНрд░рд╛рдЗрд╡рд░", driver_mobile: "рдбреНрд░рд╛рдЗрд╡рд░ рдореЛрдмрд╛рдЗрд▓", available_seats: "рдЙрдкрд▓рдмреНрдз рд╕реАрдЯреЗрдВ", total_seats: "рдХреБрд▓ рд╕реАрдЯреЗрдВ", route: "рдорд╛рд░реНрдЧ", number_plate: "рдЧрд╛рдбрд╝реА рд╕рдВрдЦреНрдпрд╛", weather: "рдореМрд╕рдо", need_bus_context: "рдмрд╕ рдХреЗ рд╡рд┐рд╡рд░рдг рдХреЗ рдмрд╛рд░реЗ рдореЗрдВ рдкреВрдЫрдиреЗ рд╕реЗ рдкрд╣рд▓реЗ рдХреГрдкрдпрд╛ рдПрдХ рдмрд╕ рдЦреЛрдЬреЗрдВред", not_provided: "рдирд╣реАрдВ рджрд┐рдпрд╛ рдЧрдпрд╛", sms_title: "рдПрд╕рдПрдордПрд╕ рдЕрдкрдбреЗрдЯ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ ЁЯУ▒", phone_placeholder: "рдЕрдкрдирд╛ рдлрд╝реЛрди рдирдВрдмрд░ рджрд░реНрдЬ рдХрд░реЗрдВ...", sms_btn_text: "рдПрд╕рдПрдордПрд╕ рднреЗрдЬреЗрдВ", sending_sms: "рднреЗрдЬ рд░рд╣рд╛ рд╣реИ...", sms_sent: "тЬЕ рдПрд╕рдПрдордПрд╕ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рднреЗрдЬрд╛ рдЧрдпрд╛!", sms_error: "тЭМ рдПрд╕рдПрдордПрд╕ рдирд╣реАрдВ рднреЗрдЬрд╛ рдЬрд╛ рд╕рдХрд╛ред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред", unrecognized_bus_number: "рдореИрдВрдиреЗ рдмрд╕ рдирдВрдмрд░ рдирд╣реАрдВ рдкрд╣рдЪрд╛рдирд╛ред рдХреГрдкрдпрд╛ рджреЛрдмрд╛рд░рд╛ р░кр▒Нр░░р░пр░др▒Нр░ир░┐р░Вр░Ър░Вр░бр░┐ред"
            },
            'te-IN': {
                welcome: "р░╕р▒Нр░╡р░╛р░Чр░др░В! р░мр░╕р▒Нр░╕р▒Б р░ир░Вр░мр░░р▒НтАМр░ир▒Б р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░Вр░бр░┐ р░▓р▒Зр░жр░╛ р░ор░╛р░Яр▒Нр░▓р░╛р░бр░Яр░╛р░ир░┐р░Хр░┐ р░ор▒Ир░Хр▒НтАМр░ир▒Б р░ир▒Кр░Хр▒Нр░Хр░Вр░бр░┐.", searching: "р░Тр░Хр▒Нр░Х р░ир░┐р░ор░┐р░╖р░В, р░ир▒Зр░ир▒Б р░Ж р░мр░╕р▒Нр░╕р▒Б р░ир░Вр░мр░░р▒Н р░Хр▒Лр░╕р░В р░др░ир░┐р░Цр▒А р░Ър▒Зр░╕р▒Нр░др▒Бр░ир▒Нр░ир░╛р░ир▒Б...", no_bus: "р░Хр▒Нр░╖р░ор░┐р░Вр░Ър░Вр░бр░┐, р░Ж р░ир░Вр░мр░░р▒НтАМр░др▒Л р░мр░╕р▒Нр░╕р▒Б р░Хр░ир▒Бр░Чр▒Кр░ир░мр░бр░▓р▒Зр░жр▒Б.", bus_found: "р░Чр▒Кр░кр▒Нр░кр░жр░┐! р░ир▒Зр░ир▒Б р░мр░╕р▒Нр░╕р▒Бр░ир▒Б р░Хр░ир▒Бр░Чр▒Кр░ир▒Нр░ир░╛р░ир▒Б. р░жр░╛р░ир░┐ р░кр▒Нр░░р░др▒Нр░пр░Хр▒Нр░╖ р░╕р▒Нр░ер░┐р░др░┐ р░Зр░Хр▒Нр░Хр░б р░Йр░Вр░жр░┐:", direct_dist_message: "ЁЯЪН...ЁЯзНр░мр░╕р▒Нр░╕р▒Б р░╕р▒Бр░ор░╛р░░р▒Б <strong>{distance} р░Хр░┐.р░ор▒А</strong> р░жр▒Вр░░р░Вр░▓р▒Л р░Йр░Вр░жр░┐. р░жр░╛р░ир░┐р░Хр░┐ р░бр▒Нр░░р▒Ир░╡р░┐р░Вр░Чр▒Н р░Ър▒Зр░пр░бр░╛р░ир░┐р░Хр░┐ р░Ер░Вр░Ър░ир░╛ р░╕р░ор░пр░В <strong>{time} р░ир░┐р░ор░┐р░╖р░╛р░▓р▒Б</strong>.", bus_arriving_message: "р░мр░╕р▒Нр░╕р▒Б р░Зр░кр▒Нр░кр▒Бр░бр▒Б р░ор▒А р░кр▒Нр░░р░жр▒Зр░╢р░╛р░ир░┐р░Хр░┐ р░╡р░╕р▒Нр░др▒Лр░Вр░жр░┐!", bus_details_title: "р░мр░╕р▒Нр░╕р▒Б #{busNumber} р░╡р░┐р░╡р░░р░╛р░▓р▒Б", intercept_plan_title: "р░Зр░Вр░Яр░░р▒НтАМр░╕р▒Жр░кр▒Нр░Яр▒Н р░кр▒Нр░▓р░╛р░ир▒Н ЁЯЧ║я╕П", intercept_stop_message: "р░ор▒Ар░░р▒Б р░мр░╕р▒Нр░╕р▒Бр░ир▒Б р░кр░Яр▒Нр░Яр▒Бр░Хр▒Лр░╡р░бр░╛р░ир░┐р░Хр░┐ р░Йр░др▒Нр░др░ор░ор▒Ир░и р░░р░╛р░мр▒Лр░пр▒З р░╕р▒Нр░Яр░╛р░кр▒Н: <strong>{stopName}</strong>", eta_user: "р░ор▒Ар░░р▒Б р░╕р▒Нр░Яр░╛р░кр▒НтАМр░Хр▒Б", eta_bus: "р░мр░╕р▒Нр░╕р▒Б р░╕р▒Нр░Яр░╛р░кр▒НтАМр░Хр▒Б", search_again: "р░ор░│р▒Нр░▓р▒А р░╢р▒Лр░зр░┐р░Вр░Ър░Вр░бр░┐", getting_location: "р░ор▒А р░▓р▒Кр░Хр▒Зр░╖р░ир▒Н р░кр▒Кр░Вр░жр▒Бр░др▒Бр░ир▒Нр░ир░╛р░ир▒Б...", location_confirmed: "р░ир▒Зр░ир▒Б р░ор▒А р░▓р▒Кр░Хр▒Зр░╖р░ир▒НтАМр░ир▒Б <strong>{city}</strong> р░╕р░ор▒Ар░кр░Вр░▓р▒Л р░Чр▒Бр░░р▒Нр░др░┐р░Вр░Ър░╛р░ир▒Б. р░ор▒Ар░░р▒Б р░Зр░кр▒Нр░кр▒Бр░бр▒Б р░мр░╕р▒Нр░╕р▒Б р░Хр▒Лр░╕р░В р░╢р▒Лр░зр░┐р░Вр░Ър░╡р░Ър▒Нр░Ър▒Б.", location_error: "р░ор▒А р░▓р▒Кр░Хр▒Зр░╖р░ир▒НтАМр░ир▒Б р░кр▒Кр░Вр░жр░▓р▒Зр░Хр░кр▒Лр░пр░╛р░ир▒Б. р░жр░пр░Ър▒Зр░╕р░┐ р░Ер░ир▒Бр░ор░др░┐ р░Зр░Ър▒Нр░Ър░┐, р░░р░┐р░лр▒Нр░░р▒Жр░╖р▒Н р░Ър▒Зр░пр░Вр░бр░┐.", no_live_location: "р░И р░мр░╕р▒Нр░╕р▒Б р░Хр░ир▒Бр░Чр▒Кр░ир░мр░бр░┐р░Вр░жр░┐, р░Хр░╛р░ир▒А р░кр▒Нр░░р░╕р▒Нр░др▒Бр░др░В р░жр░╛р░ир░┐ р░кр▒Нр░░р░др▒Нр░пр░Хр▒Нр░╖ р░▓р▒Кр░Хр▒Зр░╖р░ир▒НтАМр░ир▒Б р░кр▒Нр░░р░╕р░╛р░░р░В р░Ър▒Зр░пр░бр░В р░▓р▒Зр░жр▒Б.", bus_not_active: "р░мр░╕р▒Нр░╕р▒Б {busNumber} р░Хр░ир▒Бр░Чр▒Кр░ир░мр░бр░┐р░Вр░жр░┐, р░Хр░╛р░ир▒А р░кр▒Нр░░р░╕р▒Нр░др▒Бр░др░В р░╕р▒Зр░╡р░▓р▒Л р░▓р▒Зр░жр▒Б. р░жр░╛р░ир░┐ р░╕р▒Нр░ер░┐р░др░┐: {status}.", last_updated: "р░Ър░┐р░╡р░░р░┐р░Чр░╛ р░ир░╡р▒Ар░Хр░░р░┐р░Вр░Ър░мр░бр░┐р░Вр░жр░┐", driver_name: "р░бр▒Нр░░р▒Ир░╡р░░р▒Н", driver_mobile: "р░бр▒Нр░░р▒Ир░╡р░░р▒Н р░ор▒Кр░мр▒Ир░▓р▒Н", available_seats: "р░Ер░Вр░жр▒Бр░мр░╛р░Яр▒Бр░▓р▒Л р░Йр░ир▒Нр░и р░╕р▒Ар░Яр▒Нр░▓р▒Б", total_seats: "р░ор▒Кр░др▒Нр░др░В р░╕р▒Ар░Яр▒Нр░▓р▒Б", route: "р░ор░╛р░░р▒Нр░Чр░В", number_plate: "р░╡р░╛р░╣р░ир░В р░ир░В.", weather: "р░╡р░╛р░др░╛р░╡р░░р░гр░В", need_bus_context: "р░жр░пр░Ър▒Зр░╕р░┐ р░жр░╛р░ир░┐ р░╡р░┐р░╡р░░р░╛р░▓ р░Чр▒Бр░░р░┐р░Вр░Ър░┐ р░Ер░бр░┐р░Чр▒З р░ор▒Бр░Вр░жр▒Б р░мр░╕р▒Нр░╕р▒Бр░ир▒Б р░Хр░ир▒Бр░Чр▒Кр░ир░Вр░бр░┐.", not_provided: "р░Ер░Вр░жр░┐р░Вр░Ър░мр░бр░▓р▒Зр░жр▒Б", sms_title: "SMS р░ир░╡р▒Ар░Хр░░р░гр░▓р░ир▒Б р░кр▒Кр░Вр░жр░Вр░бр░┐ ЁЯУ▒", phone_placeholder: "р░ор▒А р░лр▒Лр░ир▒Н р░ир░Вр░мр░░р▒НтАМр░ир▒Б р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░Вр░бр░┐...", sms_btn_text: "SMS р░кр░Вр░кр░Вр░бр░┐", sending_sms: "р░кр░Вр░кр▒Бр░др▒Лр░Вр░жр░┐...", sms_sent: "тЬЕ SMS р░╡р░┐р░Ьр░пр░╡р░Вр░др░Вр░Чр░╛ р░кр░Вр░кр░мр░бр░┐р░Вр░жр░┐!", sms_error: "тЭМ SMS р░кр░Вр░кр░бр░Вр░▓р▒Л р░╡р░┐р░лр░▓р░ор▒Ир░Вр░жр░┐. р░жр░пр░Ър▒Зр░╕р░┐ р░ор░│р▒Нр░▓р▒А р░кр▒Нр░░р░пр░др▒Нр░ир░┐р░Вр░Ър░Вр░бр░┐.", unrecognized_bus_number: "р░ир▒Зр░ир▒Б р░мр░╕р▒Нр░╕р▒Б р░ир░Вр░мр░░р▒НтАМр░ир▒Б р░Чр▒Бр░░р▒Нр░др░┐р░Вр░Ър░▓р▒Зр░жр▒Б. р░жр░пр░Ър▒Зр░╕р░┐ р░ор░│р▒Нр░▓р▒А р░кр▒Нр░░р░пр░др▒Нр░ир░┐р░Вр░Ър░Вр░бр░┐."
            },
            'ta-IN': {
                welcome: "ро╡ро╛ро░рпБроЩрпНроХро│рпН! рокрпЗро░рпБроирпНродрпБ роОрогрпНрогрпИ роЙро│рпНро│ро┐роЯро╡рпБроорпН роЕро▓рпНро▓родрпБ рокрпЗроЪ роорпИроХрпНроХрпИродрпН родроЯрпНроЯро╡рпБроорпН.", searching: "рокрпКро▒рпБроЩрпНроХро│рпН, роЕроирпНрод рокрпЗро░рпБроирпНродрпБ роОрогрпНрогрпИроЪрпН роЪро░ро┐рокро╛ро░рпНроХрпНроХро┐ро▒рпЗройрпН...", no_bus: "рооройрпНройро┐роХрпНроХро╡рпБроорпН, роЕроирпНрод роОрогрпНрогро┐ро▓рпН рокрпЗро░рпБроирпНродрпБ роОродрпБро╡рпБроорпН роХро┐роЯрпИроХрпНроХро╡ро┐ро▓рпНро▓рпИ.", bus_found: "роЕро░рпБроорпИ! рокрпЗро░рпБроирпНродрпИроХрпН роХрогрпНроЯрпБрокро┐роЯро┐родрпНродрпБро╡ро┐роЯрпНроЯрпЗройрпН. роЕродройрпН роирпЗро░роЯро┐ роиро┐ро▓рпИ роЗроЩрпНроХрпЗ:", direct_dist_message: "ЁЯЪН...ЁЯзНрокрпЗро░рпБроирпНродрпБ роЪрпБрооро╛ро░рпН <strong>{distance} роХро┐.роорпА</strong> родрпКро▓рпИро╡ро┐ро▓рпН роЙро│рпНро│родрпБ. роЕродрпИ роЕроЯрпИроп роородро┐рокрпНрокро┐роЯрокрпНрокроЯрпНроЯ рокропрог роирпЗро░роорпН <strong>{time} роиро┐рооро┐роЯроЩрпНроХро│рпН</strong>.", bus_arriving_message: "рокрпЗро░рпБроирпНродрпБ роЗрокрпНрокрпЛродрпБ роЙроЩрпНроХро│рпН роЗро░рпБрокрпНрокро┐роЯродрпНродро┐ро▒рпНроХрпБ ро╡роирпНродрпБроХрпКрогрпНроЯро┐ро░рпБроХрпНроХро┐ро▒родрпБ!", bus_details_title: "рокрпЗро░рпБроирпНродрпБ #{busNumber} ро╡ро┐ро╡ро░роЩрпНроХро│рпН", intercept_plan_title: "роЗроЯрпИрооро▒ро┐рокрпНрокрпБ родро┐роЯрпНроЯроорпН ЁЯЧ║я╕П", intercept_stop_message: "роирпАроЩрпНроХро│рпН рокрпЗро░рпБроирпНродрпИрокрпН рокро┐роЯро┐рокрпНрокродро▒рпНроХро╛рой роЪро┐ро▒роирпНрод ро╡ро░ро╡ро┐ро░рпБроХрпНроХрпБроорпН роиро┐ро▒рпБродрпНродроорпН: <strong>{stopName}</strong>", eta_user: "роирпАроЩрпНроХро│рпН роиро┐ро▒рпБродрпНродродрпНродро┐ро▒рпНроХрпБ", eta_bus: "рокрпЗро░рпБроирпНродрпБ роиро┐ро▒рпБродрпНродродрпНродро┐ро▒рпНроХрпБ", search_again: "роорпАрогрпНроЯрпБроорпН родрпЗроЯрпБ", getting_location: "роЙроЩрпНроХро│рпН роЗро░рпБрокрпНрокро┐роЯродрпНродрпИрокрпН рокрпЖро▒рпБроХро┐ро▒рпЗройрпН...", location_confirmed: "роЙроЩрпНроХро│рпН роЗро░рпБрокрпНрокро┐роЯродрпНродрпИ <strong>{city}</strong> роЕро░рпБроХрпЗ роХрогрпНроЯро▒ро┐роирпНродрпБро│рпНро│рпЗройрпН. роирпАроЩрпНроХро│рпН роЗрокрпНрокрпЛродрпБ рокрпЗро░рпБроирпНродрпИродрпН родрпЗроЯро▓ро╛роорпН.", location_error: "роЙроЩрпНроХро│рпН роЗро░рпБрокрпНрокро┐роЯродрпНродрпИрокрпН рокрпЖро▒ роорпБроЯро┐ропро╡ро┐ро▓рпНро▓рпИ. родропро╡рпБроЪрпЖропрпНродрпБ роЕройрпБроородро┐ропро│ро┐родрпНродрпБ рокрпБродрпБрокрпНрокро┐роХрпНроХро╡рпБроорпН.", no_live_location: "роЗроирпНрод рокрпЗро░рпБроирпНродрпБ роХро┐роЯрпИродрпНродродрпБ, роЖройро╛ро▓рпН роЕродрпБ родро▒рпНрокрпЛродрпБ роЕродройрпН роирпЗро░роЯро┐ роЗро░рпБрокрпНрокро┐роЯродрпНродрпИ роТро│ро┐рокро░рокрпНрокро╡ро┐ро▓рпНро▓рпИ.", bus_not_active: "рокрпЗро░рпБроирпНродрпБ {busNumber} роХро┐роЯрпИродрпНродродрпБ, роЖройро╛ро▓рпН роЕродрпБ родро▒рпНрокрпЛродрпБ роЪрпЗро╡рпИропро┐ро▓рпН роЗро▓рпНро▓рпИ. роЕродройрпН роиро┐ро▓рпИ: {status}.", last_updated: "роХроЯрпИроЪро┐ропро╛роХрокрпН рокрпБродрпБрокрпНрокро┐роХрпНроХрокрпНрокроЯрпНроЯродрпБ", driver_name: "роУроЯрпНроЯрпБроиро░рпН", driver_mobile: "роУроЯрпНроЯрпБроиро░рпН роорпКрокрпИр░▓р▒Н", available_seats: "роХро┐роЯрпИроХрпНроХрпБроорпН роЗро░рпБроХрпНроХрпИроХро│рпН", total_seats: "роорпКродрпНрод роЗро░рпБроХрпНроХрпИроХро│рпН", route: "рокро╛родрпИ", number_plate: "ро╡ро╛роХрой роОрогрпН", weather: "ро╡ро╛ройро┐ро▓рпИ", need_bus_context: "роЕродройрпН ро╡ро┐ро╡ро░роЩрпНроХро│рпИроХрпН роХрпЗроЯрпНрокродро▒рпНроХрпБ роорпБройрпН, роТро░рпБ рокрпЗро░рпБроирпНродрпИроХрпН роХрогрпНроЯрпБрокро┐роЯро┐роХрпНроХро╡рпБроорпН.", not_provided: "ро╡ро┤роЩрпНроХрокрпНрокроЯро╡ро┐ро▓рпНро▓рпИ", sms_title: "SMS роЕро▒ро┐ро╡ро┐рокрпНрокрпБроХро│рпИрокрпН рокрпЖро▒ро╡рпБроорпН ЁЯУ▒", phone_placeholder: "роЙроЩрпНроХро│рпН родрпКро▓рпИрокрпЗроЪро┐ роОрогрпНрогрпИ роЙро│рпНро│ро┐роЯро╡рпБроорпН...", sms_btn_text: "SMS роЕройрпБрокрпНрокрпБ", sending_sms: "роЕройрпБрокрпНрокрпБроХро┐ро▒родрпБ...", sms_sent: "тЬЕ SMS ро╡рпЖро▒рпНро▒ро┐роХро░рооро╛роХ роЕройрпБрокрпНрокрокрпНрокроЯрпНроЯродрпБ!", sms_error: "тЭМ SMS роЕройрпБрокрпНрок роорпБроЯро┐ропро╡ро┐ро▓рпНро▓рпИ. роорпАрогрпНроЯрпБроорпН роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН.", unrecognized_bus_number: "роиро╛ройрпН рокрпЗро░рпБроирпНродрпБ роОрогрпНрогрпИ роЕроЯрпИропро╛ро│роорпН роХро╛рогро╡ро┐ро▓рпНро▓рпИ. роорпАрогрпНроЯрпБроорпН роорпБропро▒рпНроЪро┐роХрпНроХро╡рпБроорпН."
            }
        };
        
        // --- INITIALIZATION & EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeMap();
            startNewSearch();
        });
        sendBtn.addEventListener('click', () => handleUserInput());
        userInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') handleUserInput(); });
        langSelect.addEventListener('change', startNewSearch);

        chatMessages.addEventListener('click', (e) => {
            if (e.target.classList.contains('search-again-btn')) startNewSearch();
            if (e.target.id === 'sms-btn') handleSendSms();
        });
        
        if (micBtn) {
            micBtn.addEventListener('click', () => {
                recognition.lang = langSelect.value;
                recognition.start();
            });
            recognition.onstart = () => micBtn.classList.add('is-listening');
            recognition.onend = () => micBtn.classList.remove('is-listening');
            recognition.onerror = (event) => micBtn.classList.remove('is-listening');
            recognition.onresult = (event) => {
                userInput.value = event.results[0][0].transcript;
                handleUserInput();
            };
        }

        function initializeMap() {
            mapInstance = L.map('map').setView([20.5937, 78.9629], 5);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mapInstance);
            routeLayers.addTo(mapInstance);
        }

        // --- CHAT FLOW ---
        function startNewSearch() {
            if (trackingInterval) clearInterval(trackingInterval);
            chatMessages.innerHTML = '';
            currentBusData = null;
            Backendless.initApp(BACKENDLESS_APP_ID, BACKENDLESS_API_KEY);
            const lang = translations[langSelect.value] || translations['en-IN'];
            addBotMessage(lang.welcome);
            toggleInput(true);
            addBotMessage(lang.getting_location);
            getCurrentLocation().then(async (loc) => {
                userLocation = loc;
                updateUserMarker();
                const cityName = await getCityName(userLocation);
                const displayMessage = lang.location_confirmed.replace('{city}', cityName || 'your area');
                addBotMessage(displayMessage, false, cityName || '');
                toggleInput(false);
            }).catch(err => {
                addBotMessage(lang.location_error)
            });
        }

        async function handleUserInput() {
            const messageText = userInput.value.trim();
            if (!messageText) return;
            
            addUserMessage(messageText);
            userInput.value = '';
            toggleInput(true);
            await parseAndExecute(messageText);
            toggleInput(false);
        }
        
        function convertSpokenNumberToDigit(text) {
            const words = text.split(/(\s+)/); 
            const convertedWords = words.map(word => {
                const cleanWord = word.toLowerCase().replace(/[.,!?]/g, '');
                return numberWords[cleanWord] || word;
            });
            return convertedWords.join('');
        }
        
        async function parseAndExecute(text) {
            const lang = translations[langSelect.value] || translations['en-IN'];
            let processedText = convertSpokenNumberToDigit(text);

            const weatherKeywords = ['weather', 'рдореМрд╕рдо', 'р░╡р░╛р░др░╛р░╡р░░р░гр░В', 'ро╡ро╛ройро┐ро▓рпИ'];
            const seatKeywords = ['seat', 'рд╕реАрдЯ', 'р░╕р▒Ар░Яр▒Б', 'роЗроЯроорпН', 'роЗро░рпБроХрпНроХрпИроХро│рпН'];

            if (weatherKeywords.some(kw => text.toLowerCase().includes(kw))) {
                if (currentBusData) {
                    const weatherInfo = currentBusData.weather ? `<strong>${lang.weather}:</strong> ${currentBusData.weather}` : `<strong>${lang.weather}:</strong> ${lang.not_provided}`;
                    addBotMessage(weatherInfo);
                } else { addBotMessage(lang.need_bus_context); }
            } else if (seatKeywords.some(kw => text.toLowerCase().includes(kw))) {
                if (currentBusData) {
                    let seatText = `<strong>${lang.available_seats}:</strong> `;
                    seatText += (currentBusData.availableSeats !== null && currentBusData.availableSeats !== undefined) ? currentBusData.availableSeats : lang.not_provided;
                    addBotMessage(seatText);
                } else { addBotMessage(lang.need_bus_context); }
            } else {
                const busNumberMatch = processedText.match(/\d+/);
                if (busNumberMatch) {
                    await findAndDisplayBus(busNumberMatch[0]);
                } else {
                    addBotMessage(lang.unrecognized_bus_number);
                }
            }
        }
        
        async function findAndDisplayBus(busNumber) {
            const lang = translations[langSelect.value] || translations['en-IN'];
            addBotMessage(lang.searching);
            if (!userLocation) {
                addBotMessage(lang.location_error);
                addBotMessage(`<button class="search-again-btn">${lang.search_again}</button>`);
                return;
            }
            try {
                const queryBuilder = Backendless.DataQueryBuilder.create().setWhereClause(`busNumber = '${busNumber}'`);
                const buses = await Backendless.Data.of("Buses").find(queryBuilder);
                
                if (buses.length === 0) {
                    addBotMessage(lang.no_bus);
                } else {
                    const bus = buses[0];
                    if (bus.status === 'active') {
                        currentBusData = bus;
                        if (!currentBusData.currentLat || !currentBusData.currentLon) {
                            addBotMessage(lang.no_live_location);
                        } else {
                            addBotMessage(lang.bus_found);
                            await displayBusInfo(currentBusData);
                        }
                    } else {
                        addBotMessage(lang.bus_not_active.replace('{busNumber}', bus.busNumber).replace('{status}', bus.status));
                    }
                }
            } catch (error) {
                console.error("Error finding bus:", error);
            } finally {
                addBotMessage(`<button class="search-again-btn">${lang.search_again}</button>`);
            }
        }

        async function displayBusInfo(bus) {
            const messageId = `bus-info-${bus.objectId}`;
            if (document.getElementById(messageId)) document.getElementById(messageId).remove();
            
            const interceptStop = await findBestInterceptStop(bus, userLocation);
            
            const messageContainer = document.createElement('div');
            messageContainer.id = messageId;
            messageContainer.innerHTML = `<div class="direct-dist-container"></div><div class="bus-details-container"></div><div class="intercept-plan-container"></div><div class="notification-container"></div>`;
            addBotMessage(messageContainer.outerHTML, true); // Don't speak the container
            
            updateLiveElements(bus, interceptStop, messageId);
            updateMap(bus, interceptStop);

            if (trackingInterval) clearInterval(trackingInterval);
            trackingInterval = setInterval(async () => {
                const latestBus = await Backendless.Data.of("Buses").findById(bus.objectId);
                if (latestBus) {
                    currentBusData = latestBus;
                    const newInterceptStop = await findBestInterceptStop(latestBus, userLocation);
                    updateLiveElements(latestBus, newInterceptStop, messageId);
                    updateMap(latestBus, newInterceptStop);
                }
            }, 30000);
        }

        async function handleSendSms() {
            const lang = translations[langSelect.value] || translations['en-IN'];
            const phoneInput = document.getElementById('phone-input');
            const smsBtn = document.getElementById('sms-btn');
            const statusDiv = document.getElementById('sms-status');
        
            const phoneNumber = phoneInput.value.trim();
            if (!phoneNumber || !/^\+?[1-9]\d{1,14}$/.test(phoneNumber)) {
                alert('Please enter a valid phone number, including the country code (e.g., +919876543210).');
                phoneInput.focus();
                return;
            }
        
            if (!currentBusData) {
                statusDiv.textContent = 'Error: Bus data not found.';
                return;
            }
        
            smsBtn.disabled = true;
            smsBtn.textContent = lang.sending_sms;
            statusDiv.textContent = '';
        
            const busDetails = {
                busNumber: currentBusData.busNumber,
                route: `${currentBusData.source || '?'} -> ${currentBusData.destination || '?'}`,
                availableSeats: currentBusData.availableSeats,
                weather: currentBusData.weather,
                lat: currentBusData.currentLat,
                lon: currentBusData.currentLon
            };

            const langCode = langSelect.value;
        
            try {
                const response = await fetch('/send_sms', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        phone_number: phoneNumber,
                        bus_details: busDetails,
                        language: langCode
                    })
                });
        
                const result = await response.json();
                if (response.ok && result.success) {
                    statusDiv.innerHTML = `<span style="color: green;">${lang.sms_sent}</span>`;
                } else {
                    statusDiv.innerHTML = `<span style="color: red;">${lang.sms_error} ${result.error || ''}</span>`;
                }
            } catch (error) {
                console.error("Fetch API Error:", error);
                statusDiv.innerHTML = `<span style="color: red;">${lang.sms_error}</span>`;
            } finally {
                smsBtn.disabled = false;
                smsBtn.textContent = lang.sms_btn_text;
            }
        }

        // --- UI & MAP UPDATES ---
        function getTranslatedRoute(source, dest, lang) {
            if (!source || !dest) return '';
            const tSource = (placeNameTranslations[source] && placeNameTranslations[source][lang]) || source;
            const tDest = (placeNameTranslations[dest] && placeNameTranslations[dest][lang]) || dest;
            return `${tSource} to ${tDest}`;
        }
        
        async function updateLiveElements(bus, interceptStop, messageId) {
            const lang = translations[langSelect.value] || translations['en-IN'];
            const infoEl = document.getElementById(messageId);
            if (!infoEl) return;
            
            const directDistContainer = infoEl.querySelector('.direct-dist-container');
            const directRoute = await getORSRoute([userLocation.longitude, userLocation.latitude], [bus.currentLon, bus.currentLat]);
            if (directRoute && directRoute.features) {
                const summary = directRoute.features[0].properties.summary;
                const distKm = (summary.distance / 1000);
                const timeMin = Math.round(summary.duration / 60);
                directDistContainer.innerHTML = distKm < 0.15 ? lang.bus_arriving_message : lang.direct_dist_message.replace('{distance}', distKm.toFixed(1)).replace('{time}', timeMin);
            }

            const detailsContainer = infoEl.querySelector('.bus-details-container');
            const translatedRoute = getTranslatedRoute(bus.source, bus.destination, langSelect.value);
            let detailsHtml = `<div class="section-title">${lang.bus_details_title.replace('{busNumber}', bus.busNumber)}</div><ul class="details-list">`;
            detailsHtml += `<li><strong>${lang.route}:</strong> <span class="details-list-value">${translatedRoute}</span></li>`;
            if (bus.numberPlate) detailsHtml += `<li><strong>${lang.number_plate}:</strong> <span class="details-list-value">${bus.numberPlate}</span></li>`;
            if (bus.driverName) detailsHtml += `<li><strong>${lang.driver_name}:</strong> <span class="details-list-value">${bus.driverName}</span></li>`;
            if (bus.driverMobile) detailsHtml += `<li><strong>${lang.driver_mobile}:</strong> <span class="details-list-value">${bus.driverMobile}</span></li>`;
            if (bus.availableSeats !== null && bus.availableSeats !== undefined) detailsHtml += `<li><strong>${lang.available_seats}:</strong> <span class="details-list-value">${bus.availableSeats}</span></li>`;
            if (bus.totalSeats) detailsHtml += `<li><strong>${lang.total_seats}:</strong> <span class="details-list-value">${bus.totalSeats}</span></li>`;
            if (bus.weather) detailsHtml += `<li><strong>${lang.weather}:</strong> <span class="details-list-value">${bus.weather}</span></li>`;
            detailsHtml += `<li><strong>${lang.last_updated}:</strong> <span class="details-list-value">${formatTimeAgo(bus.updated)}</span></li>`;
            detailsHtml += `</ul>`;
            detailsContainer.innerHTML = detailsHtml;

            const interceptContainer = infoEl.querySelector('.intercept-plan-container');
            if (interceptStop) {
                const etaUser = await getORSRoute([userLocation.longitude, userLocation.latitude], interceptStop.coords);
                const etaBus = await getORSRoute([bus.currentLon, bus.currentLat], interceptStop.coords);
                let interceptHtml = `<div class="section-title">${lang.intercept_plan_title}</div><p>${lang.intercept_stop_message.replace('{stopName}', interceptStop.name)}</p><div class="info-grid">`;
                interceptHtml += `<div class="info-card"><h3>ЁЯУН ${lang.eta_user}</h3><p>${etaUser ? Math.round(etaUser.features[0].properties.summary.duration / 60) + ' min' : '--'}</p></div>`;
                interceptHtml += `<div class="info-card"><h3>ЁЯЪМ ${lang.eta_bus}</h3><p>${etaBus ? Math.round(etaBus.features[0].properties.summary.duration / 60) + ' min' : '--'}</p></div>`;
                interceptHtml += `</div>`;
                interceptContainer.innerHTML = interceptHtml;
            } else { interceptContainer.innerHTML = ''; }

            const notificationContainer = infoEl.querySelector('.notification-container');
            if (notificationContainer) {
                notificationContainer.innerHTML = `
                    <div class="section-title">${lang.sms_title}</div>
                    <div class="flex space-x-2 my-2">
                        <input type="tel" id="phone-input" placeholder="${lang.phone_placeholder}" class="flex-grow border rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                        <button id="sms-btn" class="bg-green-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-green-700">${lang.sms_btn_text}</button>
                    </div>
                    <div id="sms-status" class="text-sm mt-1"></div>
                `;
            }
            
            speak(infoEl.innerHTML, langSelect.value);
        }
        
        // --- UTILITY FUNCTIONS ---
        let voices = [];
        function populateVoiceList() {
            if(typeof speechSynthesis === 'undefined') {
                return;
            }
            voices = speechSynthesis.getVoices();
        }
        populateVoiceList();
        if (typeof speechSynthesis !== 'undefined' && speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoiceList;
        }

        function speak(htmlContent, lang) {
            if (!htmlContent || !('speechSynthesis' in window)) return;
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;
            const cleanText = tempDiv.textContent || tempDiv.innerText || "";
            if (!cleanText.trim()) return;

            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(cleanText.trim());
            utterance.lang = lang;
            
            const desiredVoice = voices.find(voice => voice.lang === lang);
            if (desiredVoice) {
                utterance.voice = desiredVoice;
            } else {
                console.warn(`No voice found for language: ${lang}. Using browser default.`);
            }
            
            window.speechSynthesis.speak(utterance);
        }

        function addBotMessage(content, isHtmlContainer = false, textToSpeak = null) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message bot-message`;
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.innerHTML = content;
            msgDiv.appendChild(contentDiv);
            chatMessages.appendChild(msgDiv);
            scrollToBottom();
            
            const speechText = textToSpeak !== null ? textToSpeak : content;
            if (!isHtmlContainer) {
                speak(speechText, langSelect.value);
            }
        }
        
        function updateMap(bus, stop) { if (!mapInstance) return; routeLayers.clearLayers(); const busLatLng = [bus.currentLat, bus.currentLon]; if (busMarker) busMarker.setLatLng(busLatLng); else busMarker = L.marker(busLatLng, { icon: L.icon({ iconUrl: 'https://img.icons8.com/plasticine/100/000000/bus.png', iconSize: [40, 40] }) }).addTo(mapInstance).bindPopup(`Bus #${bus.busNumber}`); const bounds = [busLatLng, [userLocation.latitude, userLocation.longitude]]; if (stop) { const stopLatLng = [stop.coords[1], stop.coords[0]]; if (stopMarker) stopMarker.setLatLng(stopLatLng); else stopMarker = L.marker(stopLatLng).addTo(mapInstance); stopMarker.setPopupContent(`Intercept at: ${stop.name}`); bounds.push(stopLatLng); drawRouteOnMap([userLocation.longitude, userLocation.latitude], stop.coords, '#3b82f6'); drawRouteOnMap([bus.currentLon, bus.currentLat], stop.coords, '#10b981'); } mapInstance.fitBounds(bounds, { padding: [50, 50] }); }
        function updateUserMarker() { if (!mapInstance || !userLocation) return; const userLatLng = [userLocation.latitude, userLocation.longitude]; if (userMarker) userMarker.setLatLng(userLatLng); else userMarker = L.marker(userLatLng, { icon: L.icon({ iconUrl: 'https://img.icons8.com/color/48/000000/marker.png', iconSize: [40, 40] }) }).addTo(mapInstance).bindPopup("Your Location"); mapInstance.setView(userLatLng, 13); }
        async function findBestInterceptStop(bus, userLoc) { let stopNames = [bus.source, ...Array.from({ length: 10 }, (_, i) => bus[`stop${i+1}`]), bus.destination].filter(Boolean); const geocodePromises = stopNames.map(name => getORSGeocode(name)); let allStops = (await Promise.all(geocodePromises)).map((r, i) => r.length > 0 ? { name: stopNames[i], coords: r[0].geometry.coordinates, originalIndex: i } : null).filter(Boolean); if (allStops.length === 0) return null; const busToStopsResults = await Promise.all(allStops.map(stop => getORSRoute([bus.currentLon, bus.currentLat], stop.coords))); let minEta = Infinity, nextStopIndex = -1; busToStopsResults.forEach((route, index) => { if (route && route.features) { const duration = route.features[0].properties.summary.duration; if (duration < minEta) { minEta = duration; nextStopIndex = allStops[index].originalIndex; } } }); const upcomingStops = allStops.filter(stop => stop.originalIndex >= nextStopIndex); if (upcomingStops.length === 0) return allStops.find(s => s.name === bus.destination) || null; const userToUpcomingStopsResults = await Promise.all(upcomingStops.map(stop => getORSRoute([userLoc.longitude, userLoc.latitude], stop.coords))); let bestStop = null, minUserDist = Infinity; userToUpcomingStopsResults.forEach((route, index) => { if (route && route.features) { const distance = route.features[0].properties.summary.distance; if (distance < minUserDist) { minUserDist = distance; bestStop = upcomingStops[index]; } } }); return bestStop; }
        async function getCityName(coords) { if (!ORS_API_KEY || ORS_API_KEY.includes('YOUR_')) return null; const url = `https://api.openrouteservice.org/geocode/reverse?api_key=${ORS_API_KEY}&point.lon=${coords.longitude}&point.lat=${coords.latitude}`; try { const response = await fetch(url); const data = await response.json(); if (data.features && data.features.length > 0) { return data.features[0].properties.locality || data.features[0].properties.county; } return null; } catch (e) { return null; } }
        async function getORSGeocode(placeName) { if (!ORS_API_KEY || ORS_API_KEY.includes('YOUR_')) return []; try { return (await (await fetch(`https://api.openrouteservice.org/geocode/search?api_key=${ORS_API_KEY}&text=${encodeURIComponent(placeName)}&boundary.country=IND`)).json()).features || []; } catch (e) { return []; } }
        async function getORSRoute(start, end) { if (!ORS_API_KEY || ORS_API_KEY.includes('YOUR_')) return null; try { const r = await fetch(`https://api.openrouteservice.org/v2/directions/driving-car/geojson`, { method: 'POST', headers: { 'Authorization': ORS_API_KEY, 'Content-Type': 'application/json' }, body: JSON.stringify({ coordinates: [start, end] }) }); return await r.json(); } catch (e) { return null; } }
        async function drawRouteOnMap(start, end, color) { const d = await getORSRoute(start, end); if (d && d.features) L.geoJSON(d, { style: { color, weight: 5, opacity: 0.7 } }).addTo(routeLayers); }
        function addUserMessage(text) { const m = document.createElement('div'); m.className = `message user-message`; m.innerHTML = `<div class="message-content">${text}</div>`; chatMessages.appendChild(m); scrollToBottom(); }
        function toggleInput(disabled) { userInput.disabled = disabled; sendBtn.disabled = disabled; }
        function scrollToBottom() { chatMessages.scrollTop = chatMessages.scrollHeight; }
        function formatTimeAgo(timestamp) { if (!timestamp) return '...'; const s = Math.floor((new Date() - new Date(timestamp)) / 1000); if (s < 30) return `just now`; if (s < 60) return `${s}s ago`; const m = Math.floor(s / 60); if (m < 60) return `${m}m ago`; const h = Math.floor(m / 60); if (h < 24) return `${h}h ago`; return `${Math.floor(h / 24)}d ago`; }
        function getCurrentLocation() { return new Promise((resolve, reject) => { if (!navigator.geolocation) { reject(new Error("Geolocation is not supported.")); } navigator.geolocation.getCurrentPosition(p => resolve(p.coords), reject, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }); }); }
    </script>
</body>
</html>